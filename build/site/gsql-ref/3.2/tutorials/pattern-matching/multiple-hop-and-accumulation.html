<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Multiple Hop Patterns and Accumulation :: TigerGraph Documentation</title>
    <meta name="generator" content="Antora 3.0.0-alpha.8">
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <script>var uiRootPath = '../../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../../../..">TigerGraph Documentation</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Resource A</a>
            <a class="navbar-item" href="#">Resource B</a>
            <a class="navbar-item" href="#">Resource C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="gsql-ref" data-version="3.2">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../intro/intro.html">GSQL Language Reference</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../intro/intro.html">Overview</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Tutorials</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../gsql-101/README.html">GSQL 101</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../gsql-101/get-set.html">Get Set</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../gsql-101/define-a-schema.html">Define a Schema</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../gsql-101/load-data-gsql-101.html">Load Data</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../gsql-101/built-in-select-queries.html">Run Built-in Queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../gsql-101/parameterized-gsql-query.html">Develop Parameterized Queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../gsql-101/review.html">Review</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="README.html">Pattern Matching Tutorial</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="get-set.html">Get Set</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="load-data.html">Load Data</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="one-hop-patterns.html">One-hop patterns</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="repeating-a-pattern.html">Repeating a 1-Hop Pattern</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="multiple-hop-and-accumulation.html">Multiple Hop Patterns and Accumulation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="example.html">Example - A Recommender</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="adv/README.html">Advanced Features</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adv/per-clause.html">Per Clause (Beta)</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adv/conjunctive-pattern-matching.html">Conjunctive Pattern Matching (Beta)</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="adv/dml.html">Data Modification</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="summary.html">Summary</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Database definition &amp; Loading</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../ddl-and-loading/system-and-language-basics.html">System &amp; Language Basics</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../ddl-and-loading/defining-a-graph-schema.html">Defining a Graph Schema</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../ddl-and-loading/modifying-a-graph-schema.html">Modifying a Graph Schema</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../ddl-and-loading/creating-a-loading-job.html">Creating a Loading Job</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../ddl-and-loading/running-a-loading-job.html">Running a Loading Job</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Appendix</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../ddl-and-loading/appendix/keywords-and-reserved-words.html">DDL Keywords &amp; Reserved Words</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#appendix/gsql-start-to-end-process.adoc">appendix/gsql-start-to-end-process.adoc</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Querying</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../querying/introduction-query.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../querying/query-operations.html">CREATE/INTERPRET/INSTALL/RUN QUERY</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../querying/distributed-query-mode.html">Distributed Query Mode</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../querying/data-types.html">Data Types</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../querying/accumulators.html">Accumulators</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../querying/operators-and-expressions.html">Operators and Expressions</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../querying/func/README.html">Functions</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/func/aggregation-functions.html">Aggregation Functions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/func/datetime-functions.html">Datetime Functions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/func/edge-methods.html">Edge Methods</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/func/json-object-methods.html">JSON Object Methods</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/func/jsonarray-methods.html">JSON Array Methods</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/func/mathematical-functions.html">Mathematical Functions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/func/miscellaneous-functions.html">Miscellaneous Functions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/func/query-user-defined-functions.html">Query User-Defined Functions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/func/string-functions.html">String Functions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/func/type-conversion-functions.html">Type Conversion Functions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/func/vertex-methods.html">Vertex Functions</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../querying/declaration-and-assignment-statements.html">Declaration and Assignment Statements</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../querying/select-statement/README.html">SELECT Statement</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/select-statement/sql-like-select-statement.html">SQL-like SELECT statement</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../querying/control-flow-statements.html">Control Flow Statements</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../querying/data-modification-statements.html">Data Modification Statements</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../querying/output-statements-and-file-objects.html">Output Statements and FILE Objects</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../querying/exception-statements.html">Exception Statements</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../querying/comments.html">Comments</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Appendix</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/appendix-query/common-errors-and-problems.html">Common Errors and Problems</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/appendix-query/complete-formal-syntax.html">Formal Grammar for Query Language</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/appendix-query/query-language-reserved-words.html">Query Language Reserved Words</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/appendix-query/example-graphs.html">Example Graphs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../querying/appendix-query/interpreted-gsql-limitations.html">Interpreted GSQL Limitations</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">GSQL Language Reference</span>
    <span class="version">3.2</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../../../tigergraph-gui/3.2/graphstudio/overview.html">GraphStudio and Admin Portal</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../tigergraph-gui/3.2/graphstudio/overview.html">3.2</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="../../intro/intro.html">GSQL Language Reference</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../intro/intro.html">3.2</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../tigergraph-cloud/latest/start/README.html">TigerGraph Cloud</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../tigergraph-cloud/latest/start/README.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../tigergraph-data-science/3.2/intro/overview.html">TigerGraph Data Science Library</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../tigergraph-data-science/3.2/intro/overview.html">3.2</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <a class="title" href="../../../../tigergraph-server/3.2/intro/introduction.html">TigerGraph Server</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../../tigergraph-server/3.2/intro/introduction.html">3.2</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../intro/intro.html">GSQL Language Reference</a></li>
    <li>Tutorials</li>
    <li><a href="README.html">Pattern Matching Tutorial</a></li>
    <li><a href="multiple-hop-and-accumulation.html">Multiple Hop Patterns and Accumulation</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/lennessyy/gsql/edit/main/modules/tutorials/pages/pattern-matching/multiple-hop-and-accumulation.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Multiple Hop Patterns and Accumulation</h1>
<div class="sect1">
<h2 id="_multiple_hop_pattern_shortest_path_semantics"><a class="anchor" href="#_multiple_hop_pattern_shortest_path_semantics"></a>Multiple Hop Pattern Shortest Path Semantics</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Repeating the same hop is useful sometimes, but the real power of pattern matching comes from expressing multi-hop patterns, with specific characteristics for each hop. For example, the well-known product recommendation phrase "People who bought this product also bought this other product", is expressed by the following 2-hop pattern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">FROM This_Product:p -(&lt;Bought:b1)- Customer:c -(Bought&gt;:b2)- Product:p2
WHERE p2 != p</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you see, a 2-hop pattern is a simple concatenation and merging of two 1-hop patterns where the two patterns share a common endpoint. Below, Y:y is the connecting end point.</p>
</div>
<h4 id="_2_hop_pattern" class="discrete">2-hop pattern</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">FROM X:x - (E1:e1) - Y:y - (E2&gt;:e2) - Z:z</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, a 3-hop pattern concatenates three 1-hop patterns in sequence, each pair of adjacent hops sharing one end point. Below, Y:y and Z:z are the connecting end points.</p>
</div>
<h4 id="_3_hop_pattern" class="discrete">3-hop pattern</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">FROM X:x - (E2&gt;:e2) - Y:y - (&lt;E3:e3) - Z:z - (E4:e4) - U:u</code></pre>
</div>
</div>
<div class="paragraph">
<p>In general, we can connect N 1-hop patterns into a N-hop pattern. The database will search the graph topology to find subgraphs that match this N-hop pattern.</p>
</div>
<h4 id="_unnamed_intermediate_vertex_set" class="discrete">Unnamed Intermediate Vertex Set</h4>
<div class="paragraph">
<p>A multi-hop pattern has two endpoint vertex sets and one or more intermediate vertex sets. If the query does not need to express any conditions for an intermediate vertex set, then the vertex set can be omitted and the two surrounding edge sets can be joined with a simple ".". For example, in the 2-hop pattern example above, if we do not need to specify the type of the intermediate vertex Y, nor need to refer to it in any of the query&#8217;s other clauses (such as WHERE or ACCUM), then the pattern can be reduced as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">FROM X:x - (E1.E2&gt;) - Z:z</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% hint style="warning" %}
Note that when we abbreviate that path in this way, we do not support aliases for the edges or intermediate vertices in the abbreviated section.
{% endhint %}</p>
</div>
<h4 id="_shortest_paths_only_for_variable_length_patterns" class="discrete">Shortest Paths Only for Variable Length Patterns</h4>
<div class="paragraph">
<p>If a pattern has a Kleene star to repeat an edge, GSQL pattern matching selects only the <em>shortest paths</em> which match the pattern. If we did not apply this restriction, computer science theory tells us that the computation time could be unbounded or extreme (NP = non-polynomial, to be technical). If we instead matched ALL paths regardless of length when a Kleene star is used without an upper bound, there could be an infinite number of matches, if there are loops in the graph. Even without loops or with an upper bound, the number of paths to check grows exponentially with the number of hops.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../.gitbook/assets/screen-shot-2019-05-22-at-12.41.56-am.png" alt="Figure 3. Shortest Path Illustration">
</div>
</div>
<div class="paragraph">
<p>For the pattern <code>1 - (_*) - 5</code> in Figure 3 above, you can see the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>There are TWO shortest paths: 1-2-3-4-5 and 1-2-6-4-5</strong></p>
<div class="ulist">
<ul>
<li>
<p>These have 4 hops, so we can stop searching after 4 hops. This makes the task tractable.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If we search for ALL paths which do not repeat any vertices:</p>
<div class="ulist">
<ul>
<li>
<p>There are THREE non-repeated-vertex paths: 1-2-3-4-5, 1-2-6-4-5, and 1-2-9-10-11-12-4-5</p>
</li>
<li>
<p>The actual number of matches is small, but the number of paths is theoretically very large.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If we search for ALL paths which do not repeat any edges:</p>
<div class="ulist">
<ul>
<li>
<p>There are FOUR non-repeated-edge paths: 1-2-3-4-5, 1-2-6-4-5, 1-2-9-10-11-12-4-5, and 1-2-3-7-8-3-4-5</p>
</li>
<li>
<p>The actual number of matches is small, but number of paths to consider is NP.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If we search for ALL paths with no restrictions:</p>
<div class="ulist">
<ul>
<li>
<p>There are an infinite number of matches, because we can go around the 3-7-8-3 cycle any number of times.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_additional_details_about_pattern_matching"><a class="anchor" href="#_additional_details_about_pattern_matching"></a>Additional Details about Pattern Matching</h2>
<div class="sectionbody">
<div class="paragraph">
<p>{% hint style="success" %}
In the early version of Pattern Matching (TigerGraph v2.4 to v2.6), there were a number of restrictions on the WHERE, ACCUM and POST-ACCUM clauses In TigerGraph 3.0, most of these restrictions are lifted.
{% endhint %}</p>
</div>
<div class="paragraph">
<p>Each vertex set or edge set in a pattern (except edges with Kleene stars) can have an alias variable associated with it. When the query runs and finds matches, it associates, or binds, each alias to the matching vertices or edges in the graph.</p>
</div>
<div class="sect2">
<h3 id="_select_clause"><a class="anchor" href="#_select_clause"></a>SELECT Clause</h3>
<div class="paragraph">
<p>The SELECT clause specifies the output vertex set of a SELECT statement. For a multiple-hop pattern, we can select any vertex alias in the pattern. The example below shows the 4 possible choices for the given pattern:</p>
</div>
<div class="paragraph">
<p>{% code title="SELECT Clause Can Select Any Vertex Alias" %}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">#select starting end point x
SELECT x
FROM X:x-(E2&gt;:e2)-Y:y-(&lt;E3:e3)-Z:z-(E4:e4)-U:u;

#select y
SELECT y
FROM X:x-(E2&gt;:e2)-Y:y-(&lt;E3:e3)-Z:z-(E4:e4)-U:u;

#select z
SELECT z
FROM X:x-(E2&gt;:e2)-Y:y-(&lt;E3:e3)-Z:z-(E4:e4)-U:u;

#select ending end point u
SELECT u
FROM X:x-(E2&gt;:e2)-Y:y-(&lt;E3:e3)-Z:z-(E4:e4)-U:u;</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% endcode %}</p>
</div>
</div>
<div class="sect2">
<h3 id="_from_clause"><a class="anchor" href="#_from_clause"></a>FROM Clause</h3>
<div class="paragraph">
<p>For a multiple-hop pattern, if you don&#8217;t need to refer to the intermediate vertex points, you can just use "." to connect the edge patterns, giving a more succinct representation. For example, below we remove y and z, and connect E2&gt;, &lt;E3 and E4 using the period symbol. Note that you cannot have an alias for a multi-hop sequence like E2&gt;.&lt;E3.E4.</p>
</div>
<div class="paragraph">
<p>{% code title="Omitting intermediate vertex y and z." %}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">#select starting end point x
SELECT x
FROM X:x-(E2&gt;:e2)-Y:y-(&lt;E3:e3)-Z:z-(E4:e4)-U:u;

#if we don't need to access y, z, we can write
SELECT u
FROM X:x-(E2&gt;.&lt;E3.E4)-U:u;</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% endcode %}</p>
</div>
</div>
<div class="sect2">
<h3 id="_where_clause"><a class="anchor" href="#_where_clause"></a>WHERE Clause</h3>
<div class="paragraph">
<p>Beginning with TigerGraph v3.0, each predicate (simple true/false condition) can refer to any of the aliases in the path. As with any database query, more complex conditions may not be as performant as simpler queries with simpler, more local predicate conditions. Consider the pattern and query below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">FROM X1:x1-(E1:e1)-X2:x2-(E2:e2)-X3:x3-(E3:e3)-X4:x4</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% code title="WHERE Clause Support both Local Predicate and Cross-hop predicates." %}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql"># (x1, e1, x2) belongs to the 1st-hop
# (x2, e2, x3) belongs to the 2nd-hop
# (x3, e3, x4) belongs to the last-hop
# below x1.age &gt; x2.age is a local predicate
# x2.@cnt != x4.@cnt is a cross-hop predicate
# (x1.salary + x3.salary) &lt; x4.salary is a cross-hop predicate
SELECT x
FROM X1:x1-(E1:e1)-X2:x2-(E2:e2)-X3:x3-(E3:e3)-X4:x4
WHERE x1.age&gt;x2.age AND x2.@cnt!=x4.@cnt AND (x1.salary+x3.salary)&lt;x4.salary</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% endcode %}</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_path_patterns_as_a_regular_expression_language"><a class="anchor" href="#_path_patterns_as_a_regular_expression_language"></a>Path Patterns as a Regular Expression Language</h2>
<div class="sectionbody">
<div class="paragraph">
<p>GSQL&#8217;s pattern matching syntax provides the essentials for a regular expression language for paths in graphs.  Consider the three basic requirements for a regular expression language:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>The empty set</strong> -&#8594; A path of length zero (no match)</p>
</li>
<li>
<p><strong>Concatenation</strong> -&#8594; Form a path by adding one on two another. You can write an N-hop pattern, and M-hop pattern, and then combine them to have a (N+M)-hop pattern.</p>
</li>
<li>
<p><strong>Alternation (either-or)</strong> -&#8594; You can use alternation for both vertex sets and edge sets, e.g. <code>FROM (Source1 | Source2) -(Edge1&gt; | &lt;Edge 2)- (Target1 | Target2)</code> Note: This is not the same as  <code>FROM (Source1 -(Edge1&gt;)- Target 1)   |   (Source2 -(&lt;Edge2)- Target 2)</code> The latter can be achieved by writing two SELECT query blocks and getting the UNION of their results.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_working_with_your_pattern_matches"><a class="anchor" href="#_working_with_your_pattern_matches"></a>Working with Your Pattern Matches</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The point of pattern matching is to identity sets of graph entities that match your input pattern. Once you&#8217;ve done that, GSQL enables you to do advanced and efficient computation on that data, from simply counting the matches to advanced algorithms and analytics. This section compares accumulation in the current Pattern Matching syntax to earlier versions, but it does not attempt to explain accumulators in full. You may want to consult the <a href="#../accumulators-tutorial.adoc" class="page unresolved">Accumulators Tutorial</a>and and the GSQL Language Reference&#8217;s section on  the <a href="../../dev/gsql-ref/querying/select-statement/#accum-and-post-accum-clauses">ACCUM and POST-ACCUM clauses</a>.</p>
</div>
<div class="sect2">
<h3 id="_accum_clause"><a class="anchor" href="#_accum_clause"></a>ACCUM Clause</h3>
<div class="paragraph">
<p>{% hint style="success" %}
TigerGraph 3.0 removes the Pattern Matching (SYNTAX v2)-related restrictions on the ACCUM and POST-ACCUM clause.
{% endhint %}</p>
</div>
<div class="paragraph">
<p>Just as in classic GSQL syntax, the ACCUM clause it executed once (in parallel) for each set of vertices and edges in the graph which match the pattern and constraints given in the FROM and WHERE clauses. You can think of FROM-WHERE as producing a virtual table. The columns of this matching table are the alias variables from the FROM clause pattern, and the rows are each possible set of vertex and edge aliases (e.g. a path) which fit the pattern.</p>
</div>
<div class="paragraph">
<p>A simple pattern 1-hop pattern, which could be syntax v1 or v2, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">FROM Person:A -(IS_LOCATED_IN:B)- City:C</code></pre>
</div>
</div>
<div class="paragraph">
<p>produces a match table with 3 columns: A, B, and C. Each row is a tuple (A,B,C) where there is a <code>has_lived_in</code> edge B from a <code>Person</code> vertex A to a <code>City</code> vertex C. We say that the match table provides a <em>binding</em> between the pattern aliases and graph&#8217;s vertices and edges. A multi-hop pattern simply has more columns than a 1-hop pattern.</p>
</div>
<div class="paragraph">
<p>{% hint style="info" %}
 The ACCUM clause iterates through ALL matches. If you do not have an alias on every vertex in the pattern, then the number of <strong>distinct</strong> matches may be less than that number of matches.
{% endhint %}</p>
</div>
<div class="paragraph">
<p>For, example, consider</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">FROM Person:A -(KNOWS.KNOWS)- Person.C
WHERE C.email = "Andy@www.com"
ACCUM C.@patternCount += 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>This asks who are the friends of friends of <a href="mailto:Andy@www.com">Andy@www.com</a>. Suppose Andy knows 3 persons (Larry, Moe, and Curly) who know Wendy. The accumulator <code>C.@patternCount</code> will be incremented 3 times for C = Wendy. This is similar to a SQL <code>SELECT C, COUNT(*) ... GROUP BY C</code> query. There is no alias for the vertex in the middle of <code>KNOWS.KNOWS</code> so the identities of Larry, Moe, and Curly cannot be reported.</p>
</div>
</div>
<div class="sect2">
<h3 id="_post_accum_clause"><a class="anchor" href="#_post_accum_clause"></a>POST-ACCUM Clause</h3>
<div class="paragraph">
<p>{% hint style="info" %}
As of TigerGraph 3.0, Pattern Matching (V2) syntax supports multiple POST-ACCUM clauses.
{% endhint %}</p>
</div>
<div class="paragraph">
<p>At the end of the ACCUM clause, all the requested accumulation (+=) operators are processed in bulk, and the updated values are now visible.  You can now use POST-ACCUM clauses to perform a second, different round of computation on the results of your pattern matching.</p>
</div>
<div class="paragraph">
<p>The <strong>ACCUM</strong> clause executes <strong>for</strong> <strong>each full path</strong> that matches the pattern in the FROM clause. In contrast, the  <strong>POST-ACCUM</strong> clause executes <strong>for each vertex</strong> in one vertex set (e.g. one vertex column in the matching table); its statements can access the aggregated accumulator result computed in the ACCUM clause. New for v3.0, if you want to perform per-vertex updates for more than one vertex alias, you should use a separate POST-ACCUM clause for each vertex alias. The multiple POST-ACCUM clauses are processed in parallel; it doesn&#8217;t matter in what order you write them. (For each binding, the statements within a clause are executed in order.)</p>
</div>
<div class="paragraph">
<p>For example, below we have two POST-ACCUM clauses. The first one iterates through s, and for each s, we do <code>s.@cnt2 += s.@cnt1</code>. The second POST-ACCUM iterations through t.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">USE GRAPH ldbc_snb

INTERPRET QUERY () SYNTAX v2 {

  SumAccum&lt;int&gt; @cnt1;
  SumAccum&lt;int&gt; @cnt2;

  R   =  SELECT s
         FROM Person:s-(LIKES&gt;) -:msg - (HAS_CREATOR&gt;)-Person:t
         WHERE s.firstName == "Viktor" AND s.lastName == "Akhiezer"
               AND t.lastName LIKE "S%" AND year(msg.creationDate) == 2012
         ACCUM s.@cnt1 +=1 //execute this per match of the FROM pattern.
         POST-ACCUM s.@cnt2 += s.@cnt1 //execute once per s.
         POST-ACCUM t.@cnt2 +=1;//execute once per t

  PRINT R [R.firstName, R.lastName, R.@cnt1, R.@cnt2];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>which produces the result</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">Using graph 'ldbc_snb'
{
  "error": false,
  "message": "",
  "version": {
    "schema": 0,
    "edition": "enterprise",
    "api": "v2"
  },
  "results": [
    {"R": [{
      "v_id": "28587302323577",
      "attributes": {
        "R.firstName": "Viktor",
        "R.@cnt1": 3,
        "R.lastName": "Akhiezer",
        "R.@cnt2": 3
      },
      "v_type": "Person"
    }]},
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the following is not allowed, since it involves two aliases (t and s) in one POST-ACCUM clause.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql"> POST-ACCUM t.@cnt1 += 1,
            s.@cnt1 += 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, you may not use more than one alias in a single assignment. The following is not allowed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql"> POST-ACCUM t.@cnt1 += s.@cnt + 1</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_examples_of_multiple_hop_pattern_match"><a class="anchor" href="#_examples_of_multiple_hop_pattern_match"></a>Examples of Multiple Hop Pattern Match</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Example 1.</strong> Find the 3rd superclass of the Tag class whose name is "TennisPlayer".</p>
</div>
<div class="paragraph">
<p>{% code title="Example1. Succinct Representation Of Multiple-hop Pattern" %}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">USE GRAPH ldbc_snb

INTERPRET QUERY () SYNTAX v2 {

  TagClass1 =
       SELECT t
       FROM TagClass:s-(IS_SUBCLASS_OF&gt;.IS_SUBCLASS_OF&gt;.IS_SUBCLASS_OF&gt;)-TagClass:t
       WHERE s.name == "TennisPlayer";

  PRINT TagClass1;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% endcode %}</p>
</div>
<div class="paragraph">
<p>You can copy the above GSQL script to a file named example1.gsql, and invoke this script file in a Linux shell.</p>
</div>
<div class="paragraph">
<p>{% code title="Linux Bash" %}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">gsql example1.gsql</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% endcode %}</p>
</div>
<div class="paragraph">
<p>{% code title=" Output of Example 1" %}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-coffeescript hljs" data-lang="coffeescript">Using graph 'ldbc_snb'
{
  "error": false,
  "message": "",
  "version": {
    "schema": 0,
    "edition": "enterprise",
    "api": "v2"
  },
  "results": [{"TagClass2": [{
    "v_id": "239",
    "attributes": {
      "name": "Agent",
      "id": 239,
      "url": "http://dbpedia.org/ontology/Agent"
    },
    "v_type": "TagClass"
  }]}]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% endcode %}</p>
</div>
<div class="paragraph">
<p><strong>Example 2.</strong> Find in which continents were the 3 most recent messages in Jan 2011 created.</p>
</div>
<div class="paragraph">
<p>{% code title="Example1. Disjunction In A Succinct Representation Of Multiple-hop Pattern" %}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">USE GRAPH ldbc_snb

INTERPRET QUERY () SYNTAX v2{

  SumAccum&lt;String&gt; @continentName;

  accMsgContinent =
                 SELECT s
                 FROM (Comment|Post):s-(IS_LOCATED_IN&gt;.IS_PART_OF&gt;)-Continent:t
                 WHERE year(s.creationDate) == 2011 AND month(s.creationDate) == 1
                 ACCUM s.@continentName = t.name
                 ORDER BY s.creationDate DESC
                 LIMIT 3;

  PRINT accMsgContinent;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% endcode %}</p>
</div>
<div class="paragraph">
<p>You can copy the above GSQL script to a file named example2.gsql, and invoke this script file in a Linux shell.</p>
</div>
<div class="paragraph">
<p>{% code title="Linux Bash" %}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">gsql example2.gsql</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% endcode %}</p>
</div>
<div class="paragraph">
<p>{% code title=" Output of Example 2" %}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-coffeescript hljs" data-lang="coffeescript">Using graph 'ldbc_snb'
{
  "error": false,
  "message": "",
  "version": {
    "schema": 0,
    "edition": "enterprise",
    "api": "v2"
  },
  "results": [{"accMsgContinent": [
    {
      "v_id": "824640012997",
      "attributes": {
        "browserUsed": "Firefox",
        "length": 7,
        "locationIP": "27.112.21.246",
        "@continentName": "Asia",
        "id": 824640012997,
        "creationDate": "2011-01-31 23:54:28",
        "content": "no way!"
      },
      "v_type": "Comment"
    },
    {
      "v_id": "824636727408",
      "attributes": {
        "browserUsed": "Firefox",
        "length": 3,
        "locationIP": "31.2.225.17",
        "@continentName": "Europe",
        "id": 824636727408,
        "creationDate": "2011-01-31 23:57:46",
        "content": "thx"
      },
      "v_type": "Comment"
    },
    {
      "v_id": "824634837528",
      "attributes": {
        "imageFile": "",
        "browserUsed": "Internet Explorer",
        "length": 115,
        "locationIP": "87.251.6.121",
        "@continentName": "Asia",
        "id": 824634837528,
        "creationDate": "2011-01-31 23:58:03",
        "lang": "tk",
        "content": "About Adolf Hitler, iews. His writings and methods were often adapted to need and circumstance, although there were"
      },
      "v_type": "Post"
    }
  ]}]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% endcode %}</p>
</div>
<div class="paragraph">
<p><strong>Example 3.</strong> Find Viktor Akhiezer&#8217;s favorite author of 2012 whose last name begins with character 'S'. Also find how many LIKES Viktor has given to the author&#8217;s post or comment.</p>
</div>
<div class="paragraph">
<p>{% code title="Example 3. Multiple-hop Pattern With Accumulator Applied To All Matched Paths" %}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">USE GRAPH ldbc_snb

INTERPRET QUERY () SYNTAX v2{
  SumAccum&lt;int&gt; @likesCnt;

  FavoriteAuthors =
            SELECT t
            FROM Person:s-(LIKES&gt;) -:msg - (HAS_CREATOR&gt;)-Person:t
            WHERE s.firstName == "Viktor" AND s.lastName == "Akhiezer"
                      AND t.lastName LIKE "S%" AND year(msg.creationDate) == 2012
            ACCUM t.@likesCnt +=1;

  PRINT FavoriteAuthors[FavoriteAuthors.firstName, FavoriteAuthors.lastName, FavoriteAuthors.@likesCnt];
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% endcode %}</p>
</div>
<div class="paragraph">
<p>You can copy the above GSQL script to a file named example3.gsql, and invoke this script file in a Linux shell.</p>
</div>
<div class="paragraph">
<p>{% code title="Linux Bash" %}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">gsql example3.gsql</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% endcode %}</p>
</div>
<div class="paragraph">
<p>{% code title=" Output of Example 3" %}</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-coffeescript hljs" data-lang="coffeescript">Using graph 'ldbc_snb'
{
  "error": false,
  "message": "",
  "version": {
    "schema": 0,
    "edition": "enterprise",
    "api": "v2"
  },
  "results": [{"FavoriteAuthors": [
    {
      "v_id": "8796093025410",
      "attributes": {
        "FavoriteAuthors.firstName": "Priyanka",
        "FavoriteAuthors.lastName": "Singh",
        "FavoriteAuthors.@likesCnt": 1
      },
      "v_type": "Person"
    },
    {
      "v_id": "2199023260091",
      "attributes": {
        "FavoriteAuthors.firstName": "Janne",
        "FavoriteAuthors.lastName": "Seppala",
        "FavoriteAuthors.@likesCnt": 1
      },
      "v_type": "Person"
    },
    {
      "v_id": "15393162796846",
      "attributes": {
        "FavoriteAuthors.firstName": "Mario",
        "FavoriteAuthors.lastName": "Santos",
        "FavoriteAuthors.@likesCnt": 1
      },
      "v_type": "Person"
    }
  ]}]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>{% endcode %}</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multi_block_queries"><a class="anchor" href="#_multi_block_queries"></a>Multi-Block Queries</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have shown how complex multi-hop patterns, containing even a conjunctive of patterns, can be expressed in a single FROM clause of a single SELECT query. There are times, however, when it is better or necessary to write query as more than one SELECT block. This could be because of the need to do computation and decision matching in stages, to make the query easier to read, or to optimize performance.</p>
</div>
<div class="paragraph">
<p>Regardless of the reason, GSQL has always supported writing procedural queries containing multiple SELECT query blocks. Moreover, each SELECT statement outputs a vertex set. This vertex set can be used in the FROM clause of an subsequence SELECT block.</p>
</div>
<div class="paragraph">
<p>For example, if Set1, Set2, and Set3 were the outputs of three previous SELECT blocks in this query, then each of these FROM clauses can take place later in the query:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FROM     Set1:x1 -(mh1)- :x2 -(mh2)- Set3:x3</code></p>
</li>
<li>
<p><code>FROM     :x1 -(mh1)- :x2 -(mh2)- Set3:x3</code></p>
</li>
<li>
<p><code>FROM     Set2:x1 -(mh1)- :x2 -(mh2)- Set2:x3</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Example 1.</strong> Find Viktor Akhiezer&#8217;s liked messages' authors, whose last name starts with letter S. Find these authors alumni count.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">USE GRAPH ldbc_snb

# a computed vertex set F is used to constrain the second pattern.
INTERPRET QUERY () SYNTAX v2 {

  SumAccum&lt;int&gt; @@cnt;

  F  =  SELECT t
        FROM :s -(LIKES&gt;:e1)- :msg -(HAS_CREATOR&gt;)- :t
        WHERE s.firstName == "Viktor" AND s.lastName == "Akhiezer" AND t.lastName LIKE "S%";

  Alumni = SELECT p
           FROM Person:p -(STUDY_AT&gt;) -:u - (&lt;STUDY_AT)- F:s
           WHERE s != p
           Per (p)
           POST-ACCUM @@cnt+=1;


  PRINT @@cnt;

}

#result
{
  "error": false,
  "message": "",
  "version": {
    "schema": 0,
    "edition": "enterprise",
    "api": "v2"
  },
  "results": [{"@@cnt": 216}]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Example 2.</strong> Find Viktor Akhiezer&#8217;s liked posts' authors A, and his liked comments' authors B. Count the common universities that both A and B have members studied at.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">USE GRAPH ldbc_snb

#A and B are used to constraint the third pattern.
INTERPRET QUERY () SYNTAX v2 {

  SumAccum&lt;int&gt; @@cnt;

  A  =  SELECT t
        FROM :s -(LIKES&gt;:e1)- Post:msg -(HAS_CREATOR&gt;)- :t
        WHERE s.firstName == "Viktor" AND s.lastName == "Akhiezer" ;


  B  =  SELECT t
        FROM :s -(LIKES&gt;:e1)- Comment:msg -(HAS_CREATOR&gt;)- :t
        WHERE s.firstName == "Viktor" AND s.lastName == "Akhiezer" ;

  Univ = SELECT u
         FROM A:p -(STUDY_AT&gt;) -:u - (&lt;STUDY_AT)- B:s
         WHERE s != p
         Per (u)
         POST-ACCUM @@cnt+=1;


  PRINT @@cnt;

}

#result
{
  "error": false,
  "message": "",
  "version": {
    "schema": 0,
    "edition": "enterprise",
    "api": "v2"
  },
  "results": [{"@@cnt": 4}]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Example 3.</strong> Find Viktor Akhiezer&#8217;s liked posts' authors A. See how many pair of persons in A that one person likes a message authored by another person.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">USE GRAPH ldbc_snb

# a computed vertex set A is used twice in the second pattern.
INTERPRET QUERY () SYNTAX v2 {

  SumAccum&lt;int&gt; @@cnt;

  A  =  SELECT t
        FROM :s -(LIKES&gt;:e1)- Post:msg -(HAS_CREATOR&gt;)- :t
        WHERE s.firstName == "Viktor" AND s.lastName == "Akhiezer" ;

  A = SELECT p
      FROM A:p -(LIKES&gt;) -:msg - (HAS_CREATOR&gt;) - A:p2
      WHERE p2 != p
      Per (p, p2)
      ACCUM @@cnt +=1;


  PRINT @@cnt;

}

#result
{
  "error": false,
  "message": "",
  "version": {
    "schema": 0,
    "edition": "enterprise",
    "api": "v2"
  },
  "results": [{"@@cnt": 14833}]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Example 4.</strong> Find how many messages are created and liked by the same person whose first name begins with letter T.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">USE GRAPH ldbc_snb

# the same alias is used twice in a pattern
INTERPRET QUERY () SYNTAX v2 {

  SumAccum&lt;int&gt; @@cnt;

  A  =  SELECT msg
        FROM :s -(LIKES&gt;:e1)- :msg -(HAS_CREATOR&gt;)- :s
        WHERE s.firstName LIKE "T%"
        PER (msg)
        ACCUM @@cnt +=1;


  PRINT @@cnt;

}
#result
{
  "error": false,
  "message": "",
  "version": {
    "schema": 0,
    "edition": "enterprise",
    "api": "v2"
  },
  "results": [{"@@cnt": 207}]
}

#to further verify, we picked one message from the above query result.
#see if there exists a person who like her own message.
INTERPRET QUERY () SYNTAX v2 {

    R = SELECT s
        FROM :msg -(HAS_CREATOR&gt;)- :s
        WHERE msg.id == 1374390714042;

    T =  SELECT s
         FROM R:s -(LIKES&gt;)- :msg
         WHERE msg.id == 1374390714042;

  PRINT R;
  PRINT T;

}

#result
{
  "error": false,
  "message": "",
  "version": {
    "schema": 0,
    "edition": "enterprise",
    "api": "v2"
  },
  "results": [
    {"R": [{
      "v_id": "13194139533433",
      "attributes": {
        "birthday": "1985-11-26 00:00:00",
        "firstName": "Taras",
        "lastName": "Kofler",
        "gender": "female",
        "speaks": [
          "uk",
          "ro",
          "en"
        ],
        "browserUsed": "Internet Explorer",
        "locationIP": "31.131.28.133",
        "id": 13194139533433,
        "creationDate": "2011-01-29 01:14:27",
        "email": [
          "Taras13194139533433@gmail.com",
          "Taras13194139533433@yahoo.com"
        ]
      },
      "v_type": "Person"
    }]},
    {"T": [{
      "v_id": "13194139533433",
      "attributes": {
        "birthday": "1985-11-26 00:00:00",
        "firstName": "Taras",
        "lastName": "Kofler",
        "gender": "female",
        "speaks": [
          "uk",
          "ro",
          "en"
        ],
        "browserUsed": "Internet Explorer",
        "locationIP": "31.131.28.133",
        "id": 13194139533433,
        "creationDate": "2011-01-29 01:14:27",
        "email": [
          "Taras13194139533433@gmail.com",
          "Taras13194139533433@yahoo.com"
        ]
      },
      "v_type": "Person"
    }]}
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>##</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../../_/js/site.js"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
